#!/usr/bin/env node

/**
 * Translation Quality Checker - kontrola a opravy p≈ôeklad≈Ø p≈ôes Claude API
 * Proch√°z√≠ p≈ôelo≈æen√© cit√°ty a vylep≈°uje je pro p≈ôirozenƒõj≈°√≠ ƒçe≈°tinu
 */

import mysql from 'mysql2/promise';
import fetch from 'node-fetch';

class TranslationQualityChecker {
  constructor() {
    this.dbConfig = {
      host: process.env.MYSQL_HOST,
      port: process.env.MYSQL_PORT,
      user: process.env.MYSQL_USER,
      password: process.env.MYSQL_PASSWORD,
      database: process.env.MYSQL_DATABASE + '_test',
      charset: 'utf8mb4'
    };
    
    this.claudeApiKey = process.env.ANTHROPIC_API_KEY;
    this.connection = null;
    
    // Rate limiting - 1 cit√°t za 10 minut = 600 sekund
    this.rateLimitMs = 10 * 60 * 1000;
    
    this.stats = {
      checked: 0,
      approved: 0,
      improved: 0,
      problematic: 0,
      errors: 0,
      totalTokens: 0
    };
  }

  async connect() {
    if (!this.connection) {
      this.connection = await mysql.createConnection(this.dbConfig);
    }
    return this.connection;
  }

  async close() {
    if (this.connection) {
      await this.connection.end();
      this.connection = null;
    }
  }

  /**
   * Z√≠skat cit√°ty s p≈ôekladem k posouzen√≠
   */
  async getTranslatedQuotes(limit = 50) {
    const conn = await this.connect();
    
    const query = `
      SELECT id, original_text, translated_text, language_code, author
      FROM quotes 
      WHERE translated_text IS NOT NULL 
        AND translated_text != '' 
        AND language_code NOT IN ('ces', 'svk')
      ORDER BY RAND()
      LIMIT ?
    `;
    
    const [rows] = await conn.execute(query, [limit]);
    return rows;
  }

  /**
   * Vol√°n√≠ Claude API pro posouzen√≠ p≈ôekladu
   */
  async checkTranslationQuality(original, translation, author, language) {
    const prompt = `Jsi profesion√°ln√≠ lingvista a p≈ôekladatel s expert√≠zou v ƒçesk√©m jazyce. Posuzuje≈° kvalitu p≈ôekladu cit√°tu s maxim√°ln√≠ preciznost√≠.

ORIGIN√ÅL (${language}): "${original}"
SOUƒåASN√ù P≈òEKLAD: "${translation}"
AUTOR: ${author || 'nezn√°m√Ω'}

KRIT√âRIA HODNOCEN√ç:
1. VƒöRNOST ORIGIN√ÅLU - Zachov√°v√° p≈ôeklad p≈ôesn√Ω v√Ωznam, n√°dech a styl?
2. P≈òIROZENOST ƒåE≈†TINY - Zn√≠ p≈ôeklad jako nativn√≠ ƒçe≈°tina nebo jako strojov√Ω p≈ôeklad?
3. POETIƒåNOST - Jsou zachov√°ny metafory, rytmus a liter√°rn√≠ kvalita?
4. GRAMATIKA - Je p≈ôeklad gramaticky spr√°vn√Ω a stylovƒõ vhodn√Ω?

ODPOVƒöZ P≈òESNƒö V TOMTO FORM√ÅTU:
- Pokud je p≈ôeklad v√Ωborn√Ω: "SCHV√ÅLENO"
- Pokud lze zlep≈°it: "OPRAVA: nov√Ω lep≈°√≠ p≈ôeklad"  
- Pokud je p≈ôeklad p≈ô√≠li≈° problematick√Ω: "PROBLEMATICK√ù: d≈Øvod probl√©mu"

PRAVIDLA:
- Zachovej p≈Øvodn√≠ smysl a emocion√°ln√≠ n√°boj
- Preferuj ƒçeskou idiomatiku p≈ôed doslovnost√≠
- Udr≈æuj stejnou d√©lku a rytmus jako origin√°l
- Buƒè velmi kritick√Ω - schvaluj jen dokonal√© p≈ôeklady`;

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.claudeApiKey,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-5-sonnet-20241022', // Claude Sonnet pro vy≈°≈°√≠ kvalitu
          max_tokens: 300, // Zv√Ω≈°eno pro detailnƒõj≈°√≠ hodnocen√≠
          messages: [{
            role: 'user',
            content: prompt
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Claude API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const content = data.content[0].text.trim();
      
      // Poƒç√≠t√°n√≠ token≈Ø pro monitoring
      const inputTokens = data.usage?.input_tokens || 0;
      const outputTokens = data.usage?.output_tokens || 0;
      const totalTokens = inputTokens + outputTokens;
      
      if (content.startsWith('SCHV√ÅLENO')) {
        return { 
          status: 'approved',
          tokens: totalTokens
        };
      }
      
      const oprava = content.match(/^OPRAVA:\s*(.+)$/);
      if (oprava) {
        return { 
          status: 'improved',
          improvedTranslation: oprava[1].replace(/^["']|["']$/g, ''),
          tokens: totalTokens
        };
      }
      
      const problem = content.match(/^PROBLEMATICK√ù:\s*(.+)$/);
      if (problem) {
        return { 
          status: 'problematic',
          reason: problem[1],
          tokens: totalTokens
        };
      }
      
      // Fallback pro neoƒçek√°van√Ω form√°t
      return { 
        status: 'improved',
        improvedTranslation: content.replace(/^["']|["']$/g, ''),
        tokens: totalTokens
      };
      
    } catch (error) {
      console.error(`‚ùå Claude API error: ${error.message}`);
      return { error: error.message };
    }
  }

  /**
   * Ulo≈æit v√Ωsledek kontroly do datab√°ze
   */
  async updateQuoteStatus(quoteId, newTranslation = null, approvalStatus = 0) {
    const conn = await this.connect();
    
    if (newTranslation) {
      const query = 'UPDATE quotes SET translated_text = ?, translation_approved = ? WHERE id = ?';
      await conn.execute(query, [newTranslation, approvalStatus, quoteId]);
    } else {
      const query = 'UPDATE quotes SET translation_approved = ? WHERE id = ?';
      await conn.execute(query, [approvalStatus, quoteId]);
    }
  }

  /**
   * Hlavn√≠ bƒõh kontroly
   */
  async run() {
    console.log('üîç SPOU≈†T√çM KONTROLU KVALITY P≈òEKLAD≈Æ');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('‚è±Ô∏è  Rate limit: 1 cit√°t za 10 minut');
    console.log('üîÑ Pro ukonƒçen√≠ stiskni Ctrl+C');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

    if (!this.claudeApiKey) {
      console.error('‚ùå Chyba: ANTHROPIC_API_KEY nen√≠ nastaven!');
      process.exit(1);
    }

    try {
      console.log('üìä Naƒç√≠t√°m cit√°ty k posouzen√≠...');
      const quotes = await this.getTranslatedQuotes(100);
      console.log(`üìù Nalezeno ${quotes.length} cit√°t≈Ø s p≈ôekladem\n`);

      for (const quote of quotes) {
        const startTime = Date.now();
        
        console.log(`üîç Kontroluji cit√°t ID ${quote.id}`);
        console.log(`üìñ Origin√°l: "${quote.original_text}"`);
        console.log(`üá®üáø P≈ôeklad: "${quote.translated_text}"`);
        console.log(`üë§ Autor: ${quote.author || 'nezn√°m√Ω'} (${quote.language_code})`);
        
        const result = await this.checkTranslationQuality(
          quote.original_text,
          quote.translated_text,
          quote.author,
          quote.language_code
        );

        if (result.error) {
          console.log(`‚ùå Chyba API: ${result.error}\n`);
          this.stats.errors++;
          continue;
        }

        // Sledov√°n√≠ token≈Ø
        this.stats.totalTokens += result.tokens || 0;
        const avgTokens = Math.round(this.stats.totalTokens / (this.stats.checked + 1));
        
        if (result.status === 'approved') {
          console.log(`‚úÖ SCHV√ÅLENO - p≈ôeklad je v√Ωborn√Ω`);
          await this.updateQuoteStatus(quote.id, null, 1); // translation_approved = 1
          this.stats.approved++;
          
        } else if (result.status === 'improved') {
          console.log(`‚ú® OPRAVA: "${result.improvedTranslation}"`);
          await this.updateQuoteStatus(quote.id, result.improvedTranslation, 0); // Z≈Øst√°v√° neschv√°len√Ω pro dal≈°√≠ kontrolu
          this.stats.improved++;
          console.log(`‚úÖ P≈ôeklad aktualizov√°n v datab√°zi`);
          
        } else if (result.status === 'problematic') {
          console.log(`‚ö†Ô∏è  PROBLEMATICK√ù: ${result.reason}`);
          await this.updateQuoteStatus(quote.id, null, 2); // translation_approved = 2
          this.stats.problematic++;
          console.log(`üö® Oznaƒçen jako problematick√Ω v datab√°zi`);
        }

        this.stats.checked++;
        
        // Zobrazit pr≈Øbƒõ≈æn√© statistiky s token monitoring
        const tokensInfo = result.tokens ? ` (${result.tokens} token≈Ø, avg: ${avgTokens})` : '';
        console.log(`üìä Statistiky: ${this.stats.checked} zkontrolov√°no, ${this.stats.approved} schv√°leno, ${this.stats.improved} opraveno, ${this.stats.problematic} probl√©mov√Ωch${tokensInfo}`);
        
        // Rate limiting - ƒçekat 10 minut minus u≈æ str√°ven√Ω ƒças
        const elapsed = Date.now() - startTime;
        const waitTime = this.rateLimitMs - elapsed;
        
        if (waitTime > 0) {
          const waitMinutes = Math.ceil(waitTime / 1000 / 60);
          console.log(`‚è≥ ƒåek√°m ${waitMinutes} minut do dal≈°√≠ho cit√°tu...\n`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        } else {
          console.log(''); // Jen pr√°zdn√Ω ≈ô√°dek
        }
      }

      this.showFinalStats();

    } catch (error) {
      console.error(`‚ùå Kritick√° chyba: ${error.message}`);
    } finally {
      await this.close();
    }
  }

  showFinalStats() {
    console.log('\nüéØ FIN√ÅLN√ç STATISTIKY:');
    console.log(`   Zkontrolov√°no: ${this.stats.checked}`);
    console.log(`   Schv√°leno (translation_approved=1): ${this.stats.approved}`);
    console.log(`   Opraveno: ${this.stats.improved}`);
    console.log(`   Problematick√© (translation_approved=2): ${this.stats.problematic}`);
    console.log(`   Chyby: ${this.stats.errors}`);
    console.log(`   Celkem token≈Ø: ${this.stats.totalTokens}`);
    
    if (this.stats.checked > 0) {
      const approvalRate = Math.round((this.stats.approved / this.stats.checked) * 100);
      const avgTokens = Math.round(this.stats.totalTokens / this.stats.checked);
      console.log(`   M√≠ra schv√°len√≠: ${approvalRate}%`);
      console.log(`   Pr≈Ømƒõr token≈Ø/cit√°t: ${avgTokens}`);
      
      // Odhad n√°klad≈Ø (Claude Sonnet ~$3 za 1M token≈Ø)
      const estimatedCost = (this.stats.totalTokens / 1000000) * 3;
      console.log(`   Odhadovan√© n√°klady: $${estimatedCost.toFixed(4)}`);
    }
  }
}

// Spu≈°tƒõn√≠
const checker = new TranslationQualityChecker();

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë Ukonƒçuji kontrolu...');
  checker.showFinalStats();
  await checker.close();
  process.exit(0);
});

checker.run().catch(console.error);